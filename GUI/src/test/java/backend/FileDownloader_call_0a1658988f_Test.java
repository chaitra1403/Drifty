/*
Test generated by RoostGPT for test test-drifty using AI Type Open AI and AI Model gpt-4

1. Scenario: Test with a YouTube or Instagram link
   - Input: Provide a valid YouTube or Instagram link
   - Expected Output: The function should correctly identify the link type and call the `downloadYoutubeOrInstagram()` method.

2. Scenario: Test with a Spotify link
   - Input: Provide a valid Spotify link
   - Expected Output: The function should correctly identify the link type, get the Spotify download link, and call the `splitDecision()` method if the link is not null.

3. Scenario: Test with an "OTHER" link type
   - Input: Provide a link of type OTHER
   - Expected Output: The function should correctly identify the link type and call the `splitDecision()` method.

4. Scenario: Test with an invalid link type
   - Input: Provide a link of an invalid type
   - Expected Output: The function should send the "INVALID_LINK" message.

5. Scenario: Test the progress update at the start of the function
   - Input: Any valid link
   - Expected Output: The progress should be updated to (0, 1) at the start of the function.

6. Scenario: Test the progress update at the end of the function
   - Input: Any valid link
   - Expected Output: The progress should be updated to (0.0, 1.0) at the end of the function.

7. Scenario: Test with a null Spotify link
   - Input: Provide a Spotify link that returns null when `getSpotifyDownloadLink(link)` is called.
   - Expected Output: The function should not call the `splitDecision()` method.

8. Scenario: Test the "done" flag and exit code at the end of the function
   - Input: Any valid link
   - Expected Output: The "done" flag should be set to true and the correct exit code should be returned at the end of the function.

9. Scenario: Test the "TRYING_TO_DOWNLOAD_F" message at the start of the function
   - Input: Any valid link
   - Expected Output: The "TRYING_TO_DOWNLOAD_F" message should be sent at the start of the function.
*/
package backend;

import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import properties.LinkType;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class FileDownloader_call_0a1658988f_Test {

    @Test
    public void testCallWithYoutubeLink() {
        FileDownloader fd = Mockito.mock(FileDownloader.class);
        fd.link = "youtube.com";
        fd.type = LinkType.YOUTUBE;

        when(fd.call()).thenCallRealMethod();
        doNothing().when(fd).downloadYoutubeOrInstagram();

        assertEquals(0, fd.call());
        verify(fd, times(1)).downloadYoutubeOrInstagram();
    }

    @Test
    public void testCallWithSpotifyLink() {
        FileDownloader fd = Mockito.mock(FileDownloader.class);
        fd.link = "spotify.com";
        fd.type = LinkType.SPOTIFY;

        when(fd.call()).thenCallRealMethod();
        when(fd.getSpotifyDownloadLink(anyString())).thenReturn("spotify.com");
        doNothing().when(fd).splitDecision();

        assertEquals(0, fd.call());
        verify(fd, times(1)).splitDecision();
    }

    @Test
    public void testCallWithOtherLink() {
        FileDownloader fd = Mockito.mock(FileDownloader.class);
        fd.link = "other.com";
        fd.type = LinkType.OTHER;

        when(fd.call()).thenCallRealMethod();
        doNothing().when(fd).splitDecision();

        assertEquals(0, fd.call());
        verify(fd, times(1)).splitDecision();
    }

    @Test
    public void testCallWithInvalidLink() {
        FileDownloader fd = Mockito.mock(FileDownloader.class);
        fd.link = "invalid.com";
        fd.type = LinkType.INVALID;

        when(fd.call()).thenCallRealMethod();
        doNothing().when(fd).sendFinalMessage(anyString());

        assertEquals(1, fd.call());
        verify(fd, times(1)).sendFinalMessage("INVALID_LINK");
    }

    @Test
    public void testCallWithNullSpotifyLink() {
        FileDownloader fd = Mockito.mock(FileDownloader.class);
        fd.link = "spotify.com";
        fd.type = LinkType.SPOTIFY;

        when(fd.call()).thenCallRealMethod();
        when(fd.getSpotifyDownloadLink(anyString())).thenReturn(null);

        assertEquals(1, fd.call());
        verify(fd, never()).splitDecision();
    }

    @Test
    public void testProgressUpdateAtStart() {
        FileDownloader fd = Mockito.mock(FileDownloader.class);
        fd.link = "youtube.com";
        fd.type = LinkType.YOUTUBE;

        when(fd.call()).thenCallRealMethod();

        fd.call();

        verify(fd, times(1)).updateProgress(0, 1);
    }

    @Test
    public void testProgressUpdateAtEnd() {
        FileDownloader fd = Mockito.mock(FileDownloader.class);
        fd.link = "youtube.com";
        fd.type = LinkType.YOUTUBE;

        when(fd.call()).thenCallRealMethod();

        fd.call();

        verify(fd, times(1)).updateProgress(0.0, 1.0);
    }

    @Test
    public void testDoneFlagAndExitCodeAtEnd() {
        FileDownloader fd = Mockito.mock(FileDownloader.class);
        fd.link = "youtube.com";
        fd.type = LinkType.YOUTUBE;

        when(fd.call()).thenCallRealMethod();

        fd.call();

        assertTrue(fd.done);
        assertEquals(0, fd.exitCode);
    }

    @Test
    public void testTryingToDownloadMessageAtStart() {
        FileDownloader fd = Mockito.mock(FileDownloader.class);
        fd.link = "youtube.com";
        fd.filename = "video.mp4";
        fd.type = LinkType.YOUTUBE;

        when(fd.call()).thenCallRealMethod();

        fd.call();

        verify(fd, times(1)).sendInfoMessage("Trying to download video.mp4");
    }
}
